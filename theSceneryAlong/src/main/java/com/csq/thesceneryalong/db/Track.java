package com.csq.thesceneryalong.db;

import java.util.List;
import com.csq.thesceneryalong.db.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, EDIT ONLY INSIDE THE "KEEP"-SECTIONS

// KEEP INCLUDES - put your custom includes here
// KEEP INCLUDES END
/**
 * Entity mapped to table TRACK.
 */
public class Track implements java.io.Serializable {

	private static final long serialVersionUID = 1L;
	
	private Long id;
    /** Not-null value. */
    private String uniqueMack;
    private Integer version;
    /** Not-null value. */
    private String name;
    private String description;
    private long beginTime;
    private Long endTime;
    private Integer pointsNum;
    private Long firstPointTime;
    private Long lastPointTime;
    private Long movingTime;
    private Double movingDistance;
    private Long simulateTime;
    private Integer sceneryNum;
    private Integer recordStatus;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient TrackDao myDao;

    private List<TrackPoint> trackPoints;
    private List<Scenery> scenerys;

    // KEEP FIELDS - put your custom fields here
    // KEEP FIELDS END

    public Track() {
    }

    public Track(Long id) {
        this.id = id;
    }

    public Track(Long id, String uniqueMack, Integer version, String name, String description, long beginTime, Long endTime, Integer pointsNum, Long firstPointTime, Long lastPointTime, Long movingTime, Double movingDistance, Long simulateTime, Integer sceneryNum, Integer recordStatus) {
        this.id = id;
        this.uniqueMack = uniqueMack;
        this.version = version;
        this.name = name;
        this.description = description;
        this.beginTime = beginTime;
        this.endTime = endTime;
        this.pointsNum = pointsNum;
        this.firstPointTime = firstPointTime;
        this.lastPointTime = lastPointTime;
        this.movingTime = movingTime;
        this.movingDistance = movingDistance;
        this.simulateTime = simulateTime;
        this.sceneryNum = sceneryNum;
        this.recordStatus = recordStatus;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getTrackDao() : null;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    /** Not-null value. */
    public String getUniqueMack() {
        return uniqueMack;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setUniqueMack(String uniqueMack) {
        this.uniqueMack = uniqueMack;
    }

    public Integer getVersion() {
        return version;
    }

    public void setVersion(Integer version) {
        this.version = version;
    }

    /** Not-null value. */
    public String getName() {
        return name;
    }

    /** Not-null value; ensure this value is available before it is saved to the database. */
    public void setName(String name) {
        this.name = name;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public long getBeginTime() {
        return beginTime;
    }

    public void setBeginTime(long beginTime) {
        this.beginTime = beginTime;
    }

    public Long getEndTime() {
        return endTime;
    }

    public void setEndTime(Long endTime) {
        this.endTime = endTime;
    }

    public Integer getPointsNum() {
        return pointsNum;
    }

    public void setPointsNum(Integer pointsNum) {
        this.pointsNum = pointsNum;
    }

    public Long getFirstPointTime() {
        return firstPointTime;
    }

    public void setFirstPointTime(Long firstPointTime) {
        this.firstPointTime = firstPointTime;
    }

    public Long getLastPointTime() {
        return lastPointTime;
    }

    public void setLastPointTime(Long lastPointTime) {
        this.lastPointTime = lastPointTime;
    }

    public Long getMovingTime() {
        return movingTime;
    }

    public void setMovingTime(Long movingTime) {
        this.movingTime = movingTime;
    }

    public Double getMovingDistance() {
        return movingDistance;
    }

    public void setMovingDistance(Double movingDistance) {
        this.movingDistance = movingDistance;
    }

    public Long getSimulateTime() {
        return simulateTime;
    }

    public void setSimulateTime(Long simulateTime) {
        this.simulateTime = simulateTime;
    }

    public Integer getSceneryNum() {
        return sceneryNum;
    }

    public void setSceneryNum(Integer sceneryNum) {
        this.sceneryNum = sceneryNum;
    }

    public Integer getRecordStatus() {
        return recordStatus;
    }

    public void setRecordStatus(Integer recordStatus) {
        this.recordStatus = recordStatus;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<TrackPoint> getTrackPoints() {
        if (trackPoints == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TrackPointDao targetDao = daoSession.getTrackPointDao();
            List<TrackPoint> trackPointsNew = targetDao._queryTrack_TrackPoints(id);
            synchronized (this) {
                if(trackPoints == null) {
                    trackPoints = trackPointsNew;
                }
            }
        }
        return trackPoints;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetTrackPoints() {
        trackPoints = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public List<Scenery> getScenerys() {
        if (scenerys == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SceneryDao targetDao = daoSession.getSceneryDao();
            List<Scenery> scenerysNew = targetDao._queryTrack_Scenerys(id);
            synchronized (this) {
                if(scenerys == null) {
                    scenerys = scenerysNew;
                }
            }
        }
        return scenerys;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetScenerys() {
        scenerys = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

    // KEEP METHODS - put your custom methods here
    // KEEP METHODS END

}
